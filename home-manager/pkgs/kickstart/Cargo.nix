# This file was @generated by crate2nix 0.9.0 with the command:
#   "generate" "-n" "/home/shados/nixpkgs-local" "-f" "/home/shados/technotheca/media/software/source/rust/kickstart/Cargo.toml" "-o" "Cargo.nix"
# See https://github.com/kolloch/crate2nix for more info.

{
  nixpkgs ? /home/shados/nixpkgs-local,
  pkgs ? import nixpkgs { config = { }; },
  lib ? pkgs.lib,
  stdenv ? pkgs.stdenv,
  buildRustCrateForPkgs ?
    if buildRustCrate != null then
      lib.warn "`buildRustCrate` is deprecated, use `buildRustCrateForPkgs` instead" (_: buildRustCrate)
    else
      pkgs: pkgs.buildRustCrate,
  # Deprecated
  buildRustCrate ? null,
  # This is used as the `crateOverrides` argument for `buildRustCrate`.
  defaultCrateOverrides ? pkgs.defaultCrateOverrides,
  # The features to enable for the root_crate or the workspace_members.
  rootFeatures ? [ "default" ],
  # If true, throw errors instead of issueing deprecation warnings.
  strictDeprecation ? false,
  # Used for conditional compilation based on CPU feature detection.
  targetFeatures ? [ ],
  # Whether to perform release builds: longer compile times, faster binaries.
  release ? true,
  # Additional crate2nix configuration if it exists.
  crateConfig ?
    if builtins.pathExists ./crate-config.nix then pkgs.callPackage ./crate-config.nix { } else { },
}:

rec {
  #
  # "public" attributes that we attempt to keep stable with new versions of crate2nix.
  #

  rootCrate = rec {
    packageId = "kickstart";

    # Use this attribute to refer to the derivation building your root crate package.
    # You can override the features with rootCrate.build.override { features = [ "default" "feature1" ... ]; }.
    build = internal.buildRustCrateWithFeatures {
      inherit packageId;
    };

    # Debug support which might change between releases.
    # File a bug if you depend on any for non-debug work!
    debug = internal.debugCrate { inherit packageId; };
  };
  # Refer your crate build derivation by name here.
  # You can override the features with
  # workspaceMembers."${crateName}".build.override { features = [ "default" "feature1" ... ]; }.
  workspaceMembers = {
    "kickstart" = rec {
      packageId = "kickstart";
      build = internal.buildRustCrateWithFeatures {
        packageId = "kickstart";
      };

      # Debug support which might change between releases.
      # File a bug if you depend on any for non-debug work!
      debug = internal.debugCrate { inherit packageId; };
    };
  };

  # A derivation that joins the outputs of all workspace members together.
  allWorkspaceMembers = pkgs.symlinkJoin {
    name = "all-workspace-members";
    paths =
      let
        members = builtins.attrValues workspaceMembers;
      in
      builtins.map (m: m.build) members;
  };

  #
  # "internal" ("private") attributes that may change in every new version of crate2nix.
  #

  internal = rec {
    # Build and dependency information for crates.
    # Many of the fields are passed one-to-one to buildRustCrate.
    #
    # Noteworthy:
    # * `dependencies`/`buildDependencies`: similar to the corresponding fields for buildRustCrate.
    #   but with additional information which is used during dependency/feature resolution.
    # * `resolvedDependencies`: the selected default features reported by cargo - only included for debugging.
    # * `devDependencies` as of now not used by `buildRustCrate` but used to
    #   inject test dependencies into the build

    crates = {
      "aho-corasick" = rec {
        crateName = "aho-corasick";
        version = "0.7.8";
        edition = "2015";
        sha256 = "048q5vr1qac4lf90z80lw8kcya6qmlxw857xhwxsssk832jdafkl";
        libName = "aho_corasick";
        authors = [
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        dependencies = [
          {
            name = "memchr";
            packageId = "memchr";
            usesDefaultFeatures = false;
          }
        ];
        features = {
          "default" = [ "std" ];
          "std" = [ "memchr/use_std" ];
        };
        resolvedDefaultFeatures = [
          "default"
          "std"
        ];
      };
      "ansi_term" = rec {
        crateName = "ansi_term";
        version = "0.11.0";
        edition = "2015";
        sha256 = "16wpvrghvd0353584i1idnsgm0r3vchg8fyrm0x8ayv1rgvbljgf";
        authors = [
          "ogham@bsago.me"
          "Ryan Scheel (Havvy) <ryan.havvy@gmail.com>"
          "Josh Triplett <josh@joshtriplett.org>"
        ];
        dependencies = [
          {
            name = "winapi";
            packageId = "winapi";
            target = { target, features }: (target."os" == "windows");
            features = [
              "errhandlingapi"
              "consoleapi"
              "processenv"
            ];
          }
        ];

      };
      "arrayref" = rec {
        crateName = "arrayref";
        version = "0.3.6";
        edition = "2015";
        sha256 = "0i6m1l3f73i0lf0cjdf5rh3xpvxydyhfbakq7xx7bkrp5qajgid4";
        authors = [
          "David Roundy <roundyd@physics.oregonstate.edu>"
        ];

      };
      "arrayvec" = rec {
        crateName = "arrayvec";
        version = "0.5.1";
        edition = "2018";
        sha256 = "1f5mca8kiiwhvhxd1mbnq68j6v6rk139sch567zwwzl6hs37vxyg";
        authors = [
          "bluss"
        ];
        features = {
          "default" = [ "std" ];
        };
      };
      "atty" = rec {
        crateName = "atty";
        version = "0.2.14";
        edition = "2015";
        sha256 = "1s7yslcs6a28c5vz7jwj63lkfgyx8mx99fdirlhi9lbhhzhrpcyr";
        authors = [
          "softprops <d.tangren@gmail.com>"
        ];
        dependencies = [
          {
            name = "hermit-abi";
            packageId = "hermit-abi";
            target = { target, features }: (target."os" == "hermit");
          }
          {
            name = "libc";
            packageId = "libc";
            usesDefaultFeatures = false;
            target = { target, features }: (target."unix" or false);
          }
          {
            name = "winapi";
            packageId = "winapi";
            target = { target, features }: (target."windows" or false);
            features = [
              "consoleapi"
              "processenv"
              "minwinbase"
              "minwindef"
              "winbase"
            ];
          }
        ];

      };
      "autocfg 0.1.7" = rec {
        crateName = "autocfg";
        version = "0.1.7";
        edition = "2015";
        sha256 = "1chwgimpx5z7xbag7krr9d8asxfqbh683qhgl9kn3hxk2l0djj8x";
        authors = [
          "Josh Stone <cuviper@gmail.com>"
        ];

      };
      "autocfg 1.0.0" = rec {
        crateName = "autocfg";
        version = "1.0.0";
        edition = "2015";
        sha256 = "17cv6pwb4q08s0ynpr4n8hv5299hcmhdgvdchzixfpw8y5qcgapq";
        authors = [
          "Josh Stone <cuviper@gmail.com>"
        ];

      };
      "base64" = rec {
        crateName = "base64";
        version = "0.11.0";
        edition = "2018";
        sha256 = "1iqmims6yvr6vwzyy54qd672zw29ipjj17p8klcr578c9ajpw6xl";
        authors = [
          "Alice Maz <alice@alicemaz.com>"
          "Marshall Pierce <marshall@mpierce.org>"
        ];
        features = {
          "default" = [ "std" ];
        };
        resolvedDefaultFeatures = [
          "default"
          "std"
        ];
      };
      "bitflags" = rec {
        crateName = "bitflags";
        version = "1.2.1";
        edition = "2015";
        sha256 = "14qnd5nq8p2almk79m4m8ydqhd413yaxsyjp5xd19g3mikzf47fg";
        authors = [
          "The Rust Project Developers"
        ];
        features = {
        };
        resolvedDefaultFeatures = [ "default" ];
      };
      "blake2b_simd" = rec {
        crateName = "blake2b_simd";
        version = "0.5.10";
        edition = "2018";
        sha256 = "12icvk8ixlivv3jv5nyrg01sajp4s279zb1kmif0nfja4ms2vyyq";
        authors = [
          "Jack O'Connor"
        ];
        dependencies = [
          {
            name = "arrayref";
            packageId = "arrayref";
          }
          {
            name = "arrayvec";
            packageId = "arrayvec";
            usesDefaultFeatures = false;
          }
          {
            name = "constant_time_eq";
            packageId = "constant_time_eq";
          }
        ];
        features = {
          "default" = [ "std" ];
        };
        resolvedDefaultFeatures = [
          "default"
          "std"
        ];
      };
      "block-buffer" = rec {
        crateName = "block-buffer";
        version = "0.7.3";
        edition = "2015";
        sha256 = "12v8wizynqin0hqf140kmp9s38q223mp1b0hkqk8j5pk8720v560";
        authors = [
          "RustCrypto Developers"
        ];
        dependencies = [
          {
            name = "block-padding";
            packageId = "block-padding";
          }
          {
            name = "byte-tools";
            packageId = "byte-tools";
          }
          {
            name = "byteorder";
            packageId = "byteorder";
            usesDefaultFeatures = false;
          }
          {
            name = "generic-array";
            packageId = "generic-array";
          }
        ];

      };
      "block-padding" = rec {
        crateName = "block-padding";
        version = "0.1.5";
        edition = "2015";
        sha256 = "1xbkmysiz23vimd17rnsjpw9bgjxipwfslwyygqlkx4in3dxwygs";
        authors = [
          "RustCrypto Developers"
        ];
        dependencies = [
          {
            name = "byte-tools";
            packageId = "byte-tools";
          }
        ];

      };
      "bstr" = rec {
        crateName = "bstr";
        version = "0.2.11";
        edition = "2015";
        sha256 = "0j1cki9nmplv99gdwrdlj8z4kf8ncid9b99qpn7xnnha392f2ajh";
        authors = [
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        dependencies = [
          {
            name = "memchr";
            packageId = "memchr";
            usesDefaultFeatures = false;
          }
        ];
        features = {
          "default" = [
            "std"
            "unicode"
          ];
          "serde1" = [
            "std"
            "serde1-nostd"
            "serde/std"
          ];
          "serde1-nostd" = [ "serde" ];
          "std" = [ "memchr/use_std" ];
          "unicode" = [
            "lazy_static"
            "regex-automata"
          ];
        };
        resolvedDefaultFeatures = [ "std" ];
      };
      "byte-tools" = rec {
        crateName = "byte-tools";
        version = "0.3.1";
        edition = "2015";
        sha256 = "1mqi29wsm8njpl51pfwr31wmpzs5ahlcb40wsjyd92l90ixcmdg3";
        authors = [
          "RustCrypto Developers"
        ];

      };
      "byteorder" = rec {
        crateName = "byteorder";
        version = "1.3.4";
        edition = "2015";
        sha256 = "1pkjfhgjnq898g1d38ygcfi0msg3m6756cwv0sgysj1d26p8mi08";
        authors = [
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        features = {
          "default" = [ "std" ];
        };
      };
      "c2-chacha" = rec {
        crateName = "c2-chacha";
        version = "0.2.3";
        edition = "2018";
        sha256 = "1fzn2n9k51b8wp4m41pkdzwlk1dbkjb6ha9rqdp4jfmzl753hhi1";
        authors = [
          "The CryptoCorrosion Contributors"
        ];
        dependencies = [
          {
            name = "ppv-lite86";
            packageId = "ppv-lite86";
            rename = "ppv-lite86";
            usesDefaultFeatures = false;
          }
        ];
        features = {
          "default" = [
            "std"
            "simd"
            "rustcrypto_api"
          ];
          "rustcrypto_api" = [
            "stream-cipher"
            "byteorder"
          ];
          "simd" = [ "ppv-lite86/simd" ];
          "std" = [ "ppv-lite86/std" ];
        };
        resolvedDefaultFeatures = [
          "simd"
          "std"
        ];
      };
      "cfg-if" = rec {
        crateName = "cfg-if";
        version = "0.1.10";
        edition = "2018";
        sha256 = "08h80ihs74jcyp24cd75wwabygbbdgl05k6p5dmq8akbr78vv1a7";
        authors = [
          "Alex Crichton <alex@alexcrichton.com>"
        ];
        features = {
          "rustc-dep-of-std" = [
            "core"
            "compiler_builtins"
          ];
        };
      };
      "chrono" = rec {
        crateName = "chrono";
        version = "0.4.10";
        edition = "2015";
        sha256 = "00dw7k11hmkm7yhc1v9pi0lrk0n28k4r3rh9g9pk3bkb9m50p19i";
        authors = [
          "Kang Seonghoon <public+rust@mearie.org>"
          "Brandon W Maister <quodlibetor@gmail.com>"
        ];
        dependencies = [
          {
            name = "num-integer";
            packageId = "num-integer";
            usesDefaultFeatures = false;
          }
          {
            name = "num-traits";
            packageId = "num-traits";
            usesDefaultFeatures = false;
          }
          {
            name = "time";
            packageId = "time";
            optional = true;
          }
        ];
        features = {
          "bench" = [ "std" ];
          "clock" = [
            "time"
            "std"
          ];
          "default" = [
            "clock"
            "std"
          ];
          "wasmbind" = [
            "wasm-bindgen"
            "js-sys"
          ];
        };
        resolvedDefaultFeatures = [
          "clock"
          "default"
          "std"
          "time"
        ];
      };
      "chrono-tz" = rec {
        crateName = "chrono-tz";
        version = "0.5.1";
        edition = "2015";
        sha256 = "05gaa4wgf9z0b870idzridx0i1mqs4ii4sywqgplskiqs3x31r70";
        authors = [
          "Djzin"
        ];
        dependencies = [
          {
            name = "chrono";
            packageId = "chrono";
            usesDefaultFeatures = false;
          }
        ];
        buildDependencies = [
          {
            name = "parse-zoneinfo";
            packageId = "parse-zoneinfo";
          }
        ];

      };
      "clap" = rec {
        crateName = "clap";
        version = "2.33.0";
        edition = "2015";
        sha256 = "1nf6ld3bims1n5vfzhkvcb55pdzh04bbhzf8nil5vvw05nxzarsh";
        authors = [
          "Kevin K. <kbknapp@gmail.com>"
        ];
        dependencies = [
          {
            name = "ansi_term";
            packageId = "ansi_term";
            optional = true;
            target = { target, features }: (!(target."windows" or false));
          }
          {
            name = "atty";
            packageId = "atty";
            optional = true;
          }
          {
            name = "bitflags";
            packageId = "bitflags";
          }
          {
            name = "strsim";
            packageId = "strsim";
            optional = true;
          }
          {
            name = "textwrap";
            packageId = "textwrap";
          }
          {
            name = "unicode-width";
            packageId = "unicode-width";
          }
          {
            name = "vec_map";
            packageId = "vec_map";
            optional = true;
          }
        ];
        features = {
          "color" = [
            "ansi_term"
            "atty"
          ];
          "default" = [
            "suggestions"
            "color"
            "vec_map"
          ];
          "doc" = [ "yaml" ];
          "lints" = [ "clippy" ];
          "suggestions" = [ "strsim" ];
          "wrap_help" = [
            "term_size"
            "textwrap/term_size"
          ];
          "yaml" = [ "yaml-rust" ];
        };
        resolvedDefaultFeatures = [
          "ansi_term"
          "atty"
          "color"
          "default"
          "strsim"
          "suggestions"
          "vec_map"
        ];
      };
      "constant_time_eq" = rec {
        crateName = "constant_time_eq";
        version = "0.1.5";
        edition = "2015";
        sha256 = "1g3vp04qzmk6cpzrd19yci6a95m7ap6wy7wkwgiy2pjklklrfl14";
        authors = [
          "Cesar Eduardo Barros <cesarb@cesarb.eti.br>"
        ];

      };
      "crossbeam-channel" = rec {
        crateName = "crossbeam-channel";
        version = "0.4.0";
        edition = "2015";
        sha256 = "135ncx9680afs8jkjz8g3iq3naay9rn7942gxrdg2n9m1cxrmv5c";
        authors = [
          "The Crossbeam Project Developers"
        ];
        dependencies = [
          {
            name = "crossbeam-utils";
            packageId = "crossbeam-utils";
          }
        ];

      };
      "crossbeam-utils" = rec {
        crateName = "crossbeam-utils";
        version = "0.7.0";
        edition = "2015";
        sha256 = "1x1rn35q2v05qif14ijfg7800d3rf3ji2cg79awnacfw5jq6si6f";
        authors = [
          "The Crossbeam Project Developers"
        ];
        dependencies = [
          {
            name = "cfg-if";
            packageId = "cfg-if";
          }
          {
            name = "lazy_static";
            packageId = "lazy_static";
            optional = true;
          }
        ];
        buildDependencies = [
          {
            name = "autocfg";
            packageId = "autocfg 0.1.7";
          }
        ];
        features = {
          "default" = [ "std" ];
          "std" = [ "lazy_static" ];
        };
        resolvedDefaultFeatures = [
          "default"
          "lazy_static"
          "std"
        ];
      };
      "deunicode" = rec {
        crateName = "deunicode";
        version = "0.4.3";
        edition = "2015";
        sha256 = "146nc3wlwz2j9awwf7zf76qvjcahnls0mlv9jm6clcvr9dlph245";
        authors = [
          "Kornel Lesinski <kornel@geekhood.net>"
          "Amit Chowdhury <amitc97@gmail.com>"
        ];

      };
      "digest" = rec {
        crateName = "digest";
        version = "0.8.1";
        edition = "2015";
        sha256 = "1madjl27f3kj5ql7kwgvb9c8b7yb7bv7yfgx7rqzj4i3fp4cil7k";
        authors = [
          "RustCrypto Developers"
        ];
        dependencies = [
          {
            name = "generic-array";
            packageId = "generic-array";
          }
        ];
        features = {
          "dev" = [ "blobby" ];
        };
      };
      "dirs" = rec {
        crateName = "dirs";
        version = "2.0.2";
        edition = "2015";
        sha256 = "1qymhyq7w7wlf1dirq6gsnabdyzg6yi2yyxkx6c4ldlkbjdaibhk";
        authors = [
          "Simon Ochsenreither <simon@ochsenreither.de>"
        ];
        dependencies = [
          {
            name = "cfg-if";
            packageId = "cfg-if";
          }
          {
            name = "dirs-sys";
            packageId = "dirs-sys";
          }
        ];

      };
      "dirs-sys" = rec {
        crateName = "dirs-sys";
        version = "0.3.4";
        edition = "2015";
        sha256 = "0yyykdcmbc476z1v9m4z5jb8y91dw6kgzpkiqi2ig07xx0yv585g";
        authors = [
          "Simon Ochsenreither <simon@ochsenreither.de>"
        ];
        dependencies = [
          {
            name = "cfg-if";
            packageId = "cfg-if";
          }
          {
            name = "libc";
            packageId = "libc";
            target = { target, features }: (target."unix" or false);
          }
          {
            name = "redox_users";
            packageId = "redox_users";
            target = { target, features }: (target."os" == "redox");
          }
          {
            name = "winapi";
            packageId = "winapi";
            target = { target, features }: (target."windows" or false);
            features = [
              "knownfolders"
              "objbase"
              "shlobj"
              "winbase"
              "winerror"
            ];
          }
        ];

      };
      "fake-simd" = rec {
        crateName = "fake-simd";
        version = "0.1.2";
        edition = "2015";
        sha256 = "1vfylvk4va2ivqx85603lyqqp0zk52cgbs4n5nfbbbqx577qm2p8";
        authors = [
          "The Rust-Crypto Project Developers"
        ];

      };
      "fnv" = rec {
        crateName = "fnv";
        version = "1.0.6";
        edition = "2015";
        sha256 = "1ww56bi1r5b8id3ns9j3qxbi7w5h005rzhiryy0zi9h97raqbb9g";
        libPath = "lib.rs";
        authors = [
          "Alex Crichton <alex@alexcrichton.com>"
        ];

      };
      "generic-array" = rec {
        crateName = "generic-array";
        version = "0.12.3";
        edition = "2015";
        sha256 = "1v5jg7djicq34nbiv1dwaki71gkny002wyy9qfn3y0hfmrs053y6";
        libName = "generic_array";
        authors = [
          "Bartłomiej Kamiński <fizyk20@gmail.com>"
          "Aaron Trent <novacrazy@gmail.com>"
        ];
        dependencies = [
          {
            name = "typenum";
            packageId = "typenum";
          }
        ];

      };
      "getrandom" = rec {
        crateName = "getrandom";
        version = "0.1.14";
        edition = "2018";
        sha256 = "1sq30li71h19rhnhs1h6576ja68insajx8wvh1nn088r8pc8vg3s";
        authors = [
          "The Rand Project Developers"
        ];
        dependencies = [
          {
            name = "cfg-if";
            packageId = "cfg-if";
          }
          {
            name = "libc";
            packageId = "libc";
            usesDefaultFeatures = false;
            target = { target, features }: (target."unix" or false);
          }
          {
            name = "wasi";
            packageId = "wasi";
            target = { target, features }: (target."os" == "wasi");
          }
        ];
        features = {
          "rustc-dep-of-std" = [
            "compiler_builtins"
            "core"
          ];
          "test-in-browser" = [ "wasm-bindgen" ];
        };
        resolvedDefaultFeatures = [ "std" ];
      };
      "glob" = rec {
        crateName = "glob";
        version = "0.3.0";
        edition = "2015";
        sha256 = "0x25wfr7vg3mzxc9x05dcphvd3nwlcmbnxrvwcvrrdwplcrrk4cv";
        authors = [
          "The Rust Project Developers"
        ];

      };
      "globset" = rec {
        crateName = "globset";
        version = "0.4.4";
        edition = "2015";
        sha256 = "1wnqxq91liknmr2w93wjq2spyxbrd1pmnhd4nbi3921dr35a4nlj";
        authors = [
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        dependencies = [
          {
            name = "aho-corasick";
            packageId = "aho-corasick";
          }
          {
            name = "bstr";
            packageId = "bstr";
            usesDefaultFeatures = false;
            features = [ "std" ];
          }
          {
            name = "fnv";
            packageId = "fnv";
          }
          {
            name = "log";
            packageId = "log";
          }
          {
            name = "regex";
            packageId = "regex";
          }
        ];
        features = {
        };
      };
      "globwalk" = rec {
        crateName = "globwalk";
        version = "0.7.1";
        edition = "2015";
        sha256 = "0yr6kcm2izsjicisjk5dzy00wh7jmh823zxqlfq9fs2rd01wzjsk";
        authors = [
          "Gilad Naaman <gilad@naaman.io>"
        ];
        dependencies = [
          {
            name = "ignore";
            packageId = "ignore";
          }
          {
            name = "walkdir";
            packageId = "walkdir";
          }
        ];

      };
      "hermit-abi" = rec {
        crateName = "hermit-abi";
        version = "0.1.6";
        edition = "2015";
        sha256 = "0wippj5nkw9q5yyyaqpdrgdhag3l3nbrwja7149cwn7ii1nnbwpg";
        authors = [
          "Stefan Lankes"
        ];
        dependencies = [
          {
            name = "libc";
            packageId = "libc";
            usesDefaultFeatures = false;
          }
        ];
        features = {
          "rustc-dep-of-std" = [
            "core"
            "compiler_builtins/rustc-dep-of-std"
            "libc/rustc-dep-of-std"
          ];
        };
        resolvedDefaultFeatures = [ "default" ];
      };
      "humansize" = rec {
        crateName = "humansize";
        version = "1.1.0";
        edition = "2015";
        sha256 = "0piadmwjah1jv6q288im4za9szlgalzjyq2811w35i6gg9ib5jmn";
        authors = [
          "Leopold Arkham <leopold.arkham@gmail.com>"
        ];

      };
      "ignore" = rec {
        crateName = "ignore";
        version = "0.4.11";
        edition = "2015";
        sha256 = "07js5k91v870b2i5rl5shg37214yzwl0p6fjqy06y0v97gyawbaj";
        authors = [
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        dependencies = [
          {
            name = "crossbeam-channel";
            packageId = "crossbeam-channel";
          }
          {
            name = "globset";
            packageId = "globset";
          }
          {
            name = "lazy_static";
            packageId = "lazy_static";
          }
          {
            name = "log";
            packageId = "log";
          }
          {
            name = "memchr";
            packageId = "memchr";
          }
          {
            name = "regex";
            packageId = "regex";
          }
          {
            name = "same-file";
            packageId = "same-file";
          }
          {
            name = "thread_local";
            packageId = "thread_local";
          }
          {
            name = "walkdir";
            packageId = "walkdir";
          }
          {
            name = "winapi-util";
            packageId = "winapi-util";
            target = { target, features }: (target."windows" or false);
          }
        ];
        features = {
          "simd-accel" = [ "globset/simd-accel" ];
        };
      };
      "itoa" = rec {
        crateName = "itoa";
        version = "0.4.5";
        edition = "2015";
        sha256 = "13nxqrfnh83a7x5rw4wq2ilp8nxvwy74dxzysdg59dbxqk0agdxq";
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
        ];
        features = {
          "default" = [ "std" ];
        };
      };
      "kickstart" = rec {
        crateName = "kickstart";
        version = "0.2.1";
        edition = "2018";
        crateBin = [
          {
            name = "kickstart";
            path = "src/bin/kickstart.rs";
          }
        ];
        src = pkgs.fetchFromGitHub {
          owner = "Keats";
          repo = "kickstart";
          rev = "38f8ddf09c4cf16eea2cce9af4568784db94c0b0";
          sha256 = "0l3qbqxk4gwl5qbh2cyhzqv0s7w67sxvpnnw8yq690zam0bp654k";
        };
        authors = [
          "Vincent Prouillet <hello@vincentprouillet.com>"
        ];
        dependencies = [
          {
            name = "clap";
            packageId = "clap";
          }
          {
            name = "glob";
            packageId = "glob";
          }
          {
            name = "memchr";
            packageId = "memchr";
          }
          {
            name = "regex";
            packageId = "regex";
          }
          {
            name = "serde";
            packageId = "serde";
            features = [ "derive" ];
          }
          {
            name = "tera";
            packageId = "tera";
          }
          {
            name = "term";
            packageId = "term";
          }
          {
            name = "toml";
            packageId = "toml";
          }
          {
            name = "walkdir";
            packageId = "walkdir";
          }
        ];
        devDependencies = [
          {
            name = "tempfile";
            packageId = "tempfile";
          }
        ];

      };
      "lazy_static" = rec {
        crateName = "lazy_static";
        version = "1.4.0";
        edition = "2015";
        sha256 = "0in6ikhw8mgl33wjv6q6xfrb5b9jr16q8ygjy803fay4zcisvaz2";
        authors = [
          "Marvin Löbel <loebel.marvin@gmail.com>"
        ];
        features = {
          "spin_no_std" = [ "spin" ];
        };
      };
      "libc" = rec {
        crateName = "libc";
        version = "0.2.66";
        edition = "2015";
        sha256 = "0n0mwry21fxfwc063k33mvxk8xj7ia5ar8m42c9ymbam2ksb25fm";
        authors = [
          "The Rust Project Developers"
        ];
        features = {
          "default" = [ "std" ];
          "rustc-dep-of-std" = [
            "align"
            "rustc-std-workspace-core"
          ];
          "use_std" = [ "std" ];
        };
        resolvedDefaultFeatures = [
          "default"
          "std"
        ];
      };
      "log" = rec {
        crateName = "log";
        version = "0.4.8";
        edition = "2015";
        sha256 = "1xz18ixccl5c6np4linv3ypc7hpmmgpc5zzd2ymp2ssfx0mhbdhl";
        authors = [
          "The Rust Project Developers"
        ];
        dependencies = [
          {
            name = "cfg-if";
            packageId = "cfg-if";
          }
        ];
        features = {
          "kv_unstable_sval" = [
            "kv_unstable"
            "sval/fmt"
          ];
        };
      };
      "maplit" = rec {
        crateName = "maplit";
        version = "1.0.2";
        edition = "2015";
        sha256 = "07b5kjnhrrmfhgqm9wprjw8adx6i225lqp49gasgqg74lahnabiy";
        authors = [
          "bluss"
        ];

      };
      "memchr" = rec {
        crateName = "memchr";
        version = "2.3.0";
        edition = "2015";
        sha256 = "08r2qw1wwvvahicjj94ci05qx3ya5ixgrpbiq23kya6vgq6f55ri";
        authors = [
          "Andrew Gallant <jamslam@gmail.com>"
          "bluss"
        ];
        features = {
          "default" = [ "std" ];
          "use_std" = [ "std" ];
        };
        resolvedDefaultFeatures = [
          "default"
          "std"
          "use_std"
        ];
      };
      "num-integer" = rec {
        crateName = "num-integer";
        version = "0.1.42";
        edition = "2015";
        sha256 = "1fpw8yr9xwsf3qrh91rm7mzqaiwlc2dmnalsxv9pr9w1klpacviz";
        authors = [
          "The Rust Project Developers"
        ];
        dependencies = [
          {
            name = "num-traits";
            packageId = "num-traits";
            usesDefaultFeatures = false;
          }
        ];
        buildDependencies = [
          {
            name = "autocfg";
            packageId = "autocfg 1.0.0";
          }
        ];
        features = {
          "default" = [ "std" ];
          "i128" = [ "num-traits/i128" ];
          "std" = [ "num-traits/std" ];
        };
      };
      "num-traits" = rec {
        crateName = "num-traits";
        version = "0.2.11";
        edition = "2015";
        sha256 = "15khrlm1bra50nd48ijl1vln13m9xg4fxzghf28jp16ic5zf8ay6";
        authors = [
          "The Rust Project Developers"
        ];
        buildDependencies = [
          {
            name = "autocfg";
            packageId = "autocfg 1.0.0";
          }
        ];
        features = {
          "default" = [ "std" ];
        };
      };
      "opaque-debug" = rec {
        crateName = "opaque-debug";
        version = "0.2.3";
        edition = "2015";
        sha256 = "172j6bs8ndclqxa2m64qc0y1772rr73g4l9fg2svscgicnbfff98";
        authors = [
          "RustCrypto Developers"
        ];

      };
      "parse-zoneinfo" = rec {
        crateName = "parse-zoneinfo";
        version = "0.2.1";
        edition = "2015";
        sha256 = "01zzysdmin7fw88vsnlwqic93wnch7zxq2nhly102h1v278fkv7y";
        authors = [
          "Djzin <djzin@users.noreply.github.com>"
        ];
        dependencies = [
          {
            name = "regex";
            packageId = "regex";
            usesDefaultFeatures = false;
            features = [
              "std"
              "unicode-perl"
            ];
          }
        ];

      };
      "percent-encoding" = rec {
        crateName = "percent-encoding";
        version = "2.1.0";
        edition = "2015";
        sha256 = "0bp3zrsk3kr47fbpipyczidbbx4g54lzxdm77ni1i3qws10mdzfl";
        libPath = "lib.rs";
        authors = [
          "The rust-url developers"
        ];

      };
      "pest" = rec {
        crateName = "pest";
        version = "2.1.2";
        edition = "2015";
        sha256 = "0jl9nv6jx1jy3fz2j49nw7jkh9z5igvrbvsgnbc5aan2ql0v4kvy";
        authors = [
          "Dragoș Tiselice <dragostiselice@gmail.com>"
        ];
        dependencies = [
          {
            name = "ucd-trie";
            packageId = "ucd-trie";
          }
        ];
        features = {
          "pretty-print" = [
            "serde"
            "serde_json"
          ];
        };
      };
      "pest_derive" = rec {
        crateName = "pest_derive";
        version = "2.1.0";
        edition = "2015";
        sha256 = "1l5jfa6ril71cw5nsiw0r45br54dd8cj2r1nc2d1wq6wb3jilgc3";
        procMacro = true;
        authors = [
          "Dragoș Tiselice <dragostiselice@gmail.com>"
        ];
        dependencies = [
          {
            name = "pest";
            packageId = "pest";
          }
          {
            name = "pest_generator";
            packageId = "pest_generator";
          }
        ];

      };
      "pest_generator" = rec {
        crateName = "pest_generator";
        version = "2.1.1";
        edition = "2015";
        sha256 = "1h3z8jccki87mn7gppy4292s1ah98z4md998w5pd04jpkclwz7vv";
        authors = [
          "Dragoș Tiselice <dragostiselice@gmail.com>"
        ];
        dependencies = [
          {
            name = "pest";
            packageId = "pest";
          }
          {
            name = "pest_meta";
            packageId = "pest_meta";
          }
          {
            name = "proc-macro2";
            packageId = "proc-macro2";
          }
          {
            name = "quote";
            packageId = "quote";
          }
          {
            name = "syn";
            packageId = "syn";
          }
        ];

      };
      "pest_meta" = rec {
        crateName = "pest_meta";
        version = "2.1.2";
        edition = "2015";
        sha256 = "0iymvrh7lcfi8iarkgq0hwgarr00np3l4xg4bx42rmvgi6czshyz";
        authors = [
          "Dragoș Tiselice <dragostiselice@gmail.com>"
        ];
        dependencies = [
          {
            name = "maplit";
            packageId = "maplit";
          }
          {
            name = "pest";
            packageId = "pest";
          }
        ];
        buildDependencies = [
          {
            name = "sha-1";
            packageId = "sha-1";
            usesDefaultFeatures = false;
          }
        ];

      };
      "ppv-lite86" = rec {
        crateName = "ppv-lite86";
        version = "0.2.6";
        edition = "2018";
        sha256 = "06zs492wbms7j5qhy58cs3976c7kyc47rx0d6fn63rgvp580njbl";
        authors = [
          "The CryptoCorrosion Contributors"
        ];
        features = {
          "default" = [
            "std"
            "simd"
          ];
        };
        resolvedDefaultFeatures = [
          "simd"
          "std"
        ];
      };
      "proc-macro2" = rec {
        crateName = "proc-macro2";
        version = "1.0.8";
        edition = "2018";
        sha256 = "0j45p176fnw0d02dzcky9sxyr4fadiggq07skmblwspqdxy33jrs";
        authors = [
          "Alex Crichton <alex@alexcrichton.com>"
        ];
        dependencies = [
          {
            name = "unicode-xid";
            packageId = "unicode-xid";
          }
        ];
        features = {
          "default" = [ "proc-macro" ];
        };
        resolvedDefaultFeatures = [
          "default"
          "proc-macro"
        ];
      };
      "quote" = rec {
        crateName = "quote";
        version = "1.0.2";
        edition = "2018";
        sha256 = "1zkc46ryacf2jdkc6krsy2z615xbk1x8kp1830rcxz3irj5qqfh5";
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
        ];
        dependencies = [
          {
            name = "proc-macro2";
            packageId = "proc-macro2";
            usesDefaultFeatures = false;
          }
        ];
        features = {
          "default" = [ "proc-macro" ];
          "proc-macro" = [ "proc-macro2/proc-macro" ];
        };
        resolvedDefaultFeatures = [
          "default"
          "proc-macro"
        ];
      };
      "rand" = rec {
        crateName = "rand";
        version = "0.7.3";
        edition = "2018";
        sha256 = "00sdaimkbz491qgi6qxkv582yivl32m2jd401kzbn94vsiwicsva";
        authors = [
          "The Rand Project Developers"
          "The Rust Project Developers"
        ];
        dependencies = [
          {
            name = "getrandom";
            packageId = "getrandom";
            rename = "getrandom_package";
            optional = true;
          }
          {
            name = "libc";
            packageId = "libc";
            optional = true;
            usesDefaultFeatures = false;
            target = { target, features }: (target."unix" or false);
          }
          {
            name = "rand_chacha";
            packageId = "rand_chacha";
            usesDefaultFeatures = false;
            target = { target, features }: (!(target."os" == "emscripten"));
          }
          {
            name = "rand_core";
            packageId = "rand_core";
          }
          {
            name = "rand_hc";
            packageId = "rand_hc";
            target = { target, features }: (target."os" == "emscripten");
          }
        ];
        devDependencies = [
          {
            name = "rand_hc";
            packageId = "rand_hc";
          }
        ];
        features = {
          "alloc" = [ "rand_core/alloc" ];
          "default" = [ "std" ];
          "getrandom" = [
            "getrandom_package"
            "rand_core/getrandom"
          ];
          "nightly" = [ "simd_support" ];
          "simd_support" = [ "packed_simd" ];
          "small_rng" = [ "rand_pcg" ];
          "std" = [
            "rand_core/std"
            "rand_chacha/std"
            "alloc"
            "getrandom"
            "libc"
          ];
          "stdweb" = [ "getrandom_package/stdweb" ];
          "wasm-bindgen" = [ "getrandom_package/wasm-bindgen" ];
        };
        resolvedDefaultFeatures = [
          "alloc"
          "default"
          "getrandom"
          "getrandom_package"
          "libc"
          "std"
        ];
      };
      "rand_chacha" = rec {
        crateName = "rand_chacha";
        version = "0.2.1";
        edition = "2018";
        sha256 = "0lv8imzzl4h2glm6sjj8mkvasgi8jym23ya48dakyln7m06sk8h3";
        authors = [
          "The Rand Project Developers"
          "The Rust Project Developers"
          "The CryptoCorrosion Contributors"
        ];
        dependencies = [
          {
            name = "c2-chacha";
            packageId = "c2-chacha";
            usesDefaultFeatures = false;
            features = [ "simd" ];
          }
          {
            name = "rand_core";
            packageId = "rand_core";
          }
        ];
        features = {
          "default" = [
            "std"
            "simd"
          ];
          "std" = [ "c2-chacha/std" ];
        };
        resolvedDefaultFeatures = [ "std" ];
      };
      "rand_core" = rec {
        crateName = "rand_core";
        version = "0.5.1";
        edition = "2018";
        sha256 = "06bdvx08v3rkz451cm7z59xwwqn1rkfh6v9ay77b14f8dwlybgch";
        authors = [
          "The Rand Project Developers"
          "The Rust Project Developers"
        ];
        dependencies = [
          {
            name = "getrandom";
            packageId = "getrandom";
            optional = true;
          }
        ];
        features = {
          "serde1" = [ "serde" ];
          "std" = [
            "alloc"
            "getrandom"
            "getrandom/std"
          ];
        };
        resolvedDefaultFeatures = [
          "alloc"
          "getrandom"
          "std"
        ];
      };
      "rand_hc" = rec {
        crateName = "rand_hc";
        version = "0.2.0";
        edition = "2018";
        sha256 = "0g31sqwpmsirdlwr0svnacr4dbqyz339im4ssl9738cjgfpjjcfa";
        authors = [
          "The Rand Project Developers"
        ];
        dependencies = [
          {
            name = "rand_core";
            packageId = "rand_core";
          }
        ];

      };
      "redox_syscall" = rec {
        crateName = "redox_syscall";
        version = "0.1.56";
        edition = "2015";
        sha256 = "110y7dyfm2vci4x5vk7gr0q551dvp31npl99fnsx2fb17wzwcf94";
        libName = "syscall";
        authors = [
          "Jeremy Soller <jackpot51@gmail.com>"
        ];

      };
      "redox_users" = rec {
        crateName = "redox_users";
        version = "0.3.4";
        edition = "2015";
        sha256 = "0cbl5w16l3bqm22i4vszclf6hzpljxicghmllw7j13az4s9k1ch9";
        authors = [
          "Jose Narvaez <goyox86@gmail.com>"
          "Wesley Hershberger <mggmugginsmc@gmail.com>"
        ];
        dependencies = [
          {
            name = "getrandom";
            packageId = "getrandom";
          }
          {
            name = "redox_syscall";
            packageId = "redox_syscall";
          }
          {
            name = "rust-argon2";
            packageId = "rust-argon2";
          }
        ];

      };
      "regex" = rec {
        crateName = "regex";
        version = "1.3.4";
        edition = "2015";
        sha256 = "1a1mh9mgr8jipnxdaykla6xlw4a6kjn2bzkq3cifx8xy4ivzjb1j";
        authors = [
          "The Rust Project Developers"
        ];
        dependencies = [
          {
            name = "aho-corasick";
            packageId = "aho-corasick";
            optional = true;
          }
          {
            name = "memchr";
            packageId = "memchr";
            optional = true;
          }
          {
            name = "regex-syntax";
            packageId = "regex-syntax";
            usesDefaultFeatures = false;
          }
          {
            name = "thread_local";
            packageId = "thread_local";
            optional = true;
          }
        ];
        features = {
          "default" = [
            "std"
            "perf"
            "unicode"
          ];
          "perf" = [
            "perf-cache"
            "perf-dfa"
            "perf-inline"
            "perf-literal"
          ];
          "perf-cache" = [ "thread_local" ];
          "perf-literal" = [
            "aho-corasick"
            "memchr"
          ];
          "unicode" = [
            "unicode-age"
            "unicode-bool"
            "unicode-case"
            "unicode-gencat"
            "unicode-perl"
            "unicode-script"
            "unicode-segment"
          ];
          "unicode-age" = [ "regex-syntax/unicode-age" ];
          "unicode-bool" = [ "regex-syntax/unicode-bool" ];
          "unicode-case" = [ "regex-syntax/unicode-case" ];
          "unicode-gencat" = [ "regex-syntax/unicode-gencat" ];
          "unicode-perl" = [ "regex-syntax/unicode-perl" ];
          "unicode-script" = [ "regex-syntax/unicode-script" ];
          "unicode-segment" = [ "regex-syntax/unicode-segment" ];
          "unstable" = [ "pattern" ];
          "use_std" = [ "std" ];
        };
        resolvedDefaultFeatures = [
          "aho-corasick"
          "default"
          "memchr"
          "perf"
          "perf-cache"
          "perf-dfa"
          "perf-inline"
          "perf-literal"
          "std"
          "thread_local"
          "unicode"
          "unicode-age"
          "unicode-bool"
          "unicode-case"
          "unicode-gencat"
          "unicode-perl"
          "unicode-script"
          "unicode-segment"
        ];
      };
      "regex-syntax" = rec {
        crateName = "regex-syntax";
        version = "0.6.14";
        edition = "2015";
        sha256 = "01myl8xqpbnird23xnsb92sjmz1cmp69r6m7y3dwbpmsx4zzx3dj";
        authors = [
          "The Rust Project Developers"
        ];
        features = {
          "default" = [ "unicode" ];
          "unicode" = [
            "unicode-age"
            "unicode-bool"
            "unicode-case"
            "unicode-gencat"
            "unicode-perl"
            "unicode-script"
            "unicode-segment"
          ];
        };
        resolvedDefaultFeatures = [
          "unicode-age"
          "unicode-bool"
          "unicode-case"
          "unicode-gencat"
          "unicode-perl"
          "unicode-script"
          "unicode-segment"
        ];
      };
      "remove_dir_all" = rec {
        crateName = "remove_dir_all";
        version = "0.5.2";
        edition = "2015";
        sha256 = "0bkrlyg26mgizpiy1yb2hhpgscxcag8r5fnckqsvk25608vzm0sa";
        authors = [
          "Aaronepower <theaaronepower@gmail.com>"
        ];
        dependencies = [
          {
            name = "winapi";
            packageId = "winapi";
            target = { target, features }: (target."windows" or false);
            features = [
              "std"
              "errhandlingapi"
              "winerror"
              "fileapi"
              "winbase"
            ];
          }
        ];

      };
      "rust-argon2" = rec {
        crateName = "rust-argon2";
        version = "0.7.0";
        edition = "2018";
        sha256 = "05xh5wfxgzq3b6jys8r34f3hmqqfs8ylvf934n9z87wfv95szj1b";
        libName = "argon2";
        authors = [
          "Martijn Rijkeboer <mrr@sru-systems.com>"
        ];
        dependencies = [
          {
            name = "base64";
            packageId = "base64";
          }
          {
            name = "blake2b_simd";
            packageId = "blake2b_simd";
          }
          {
            name = "constant_time_eq";
            packageId = "constant_time_eq";
          }
          {
            name = "crossbeam-utils";
            packageId = "crossbeam-utils";
          }
        ];

      };
      "ryu" = rec {
        crateName = "ryu";
        version = "1.0.2";
        edition = "2015";
        sha256 = "1j0h74f1xqf9hjkhanp8i20mqc1aw35kr1iq9i79q7713mn51a5z";
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
        ];
        features = {
        };
      };
      "same-file" = rec {
        crateName = "same-file";
        version = "1.0.6";
        edition = "2018";
        sha256 = "00h5j1w87dmhnvbv9l8bic3y7xxsnjmssvifw2ayvgx9mb1ivz4k";
        authors = [
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        dependencies = [
          {
            name = "winapi-util";
            packageId = "winapi-util";
            target = { target, features }: (target."windows" or false);
          }
        ];

      };
      "serde" = rec {
        crateName = "serde";
        version = "1.0.104";
        edition = "2015";
        sha256 = "0ja4mgw4p42syjk7jkzwhj2yg6llfrfm7vn8rvy7v3c1bzr1aha1";
        authors = [
          "Erick Tryzelaar <erick.tryzelaar@gmail.com>"
          "David Tolnay <dtolnay@gmail.com>"
        ];
        dependencies = [
          {
            name = "serde_derive";
            packageId = "serde_derive";
            optional = true;
          }
        ];
        devDependencies = [
          {
            name = "serde_derive";
            packageId = "serde_derive";
          }
        ];
        features = {
          "default" = [ "std" ];
          "derive" = [ "serde_derive" ];
        };
        resolvedDefaultFeatures = [
          "default"
          "derive"
          "serde_derive"
          "std"
        ];
      };
      "serde_derive" = rec {
        crateName = "serde_derive";
        version = "1.0.104";
        edition = "2015";
        sha256 = "0r7gjlwfry44b4ylz524ynjp9v3qiwdj4c588lh94aas78q9x3qj";
        procMacro = true;
        authors = [
          "Erick Tryzelaar <erick.tryzelaar@gmail.com>"
          "David Tolnay <dtolnay@gmail.com>"
        ];
        dependencies = [
          {
            name = "proc-macro2";
            packageId = "proc-macro2";
          }
          {
            name = "quote";
            packageId = "quote";
          }
          {
            name = "syn";
            packageId = "syn";
            features = [ "visit" ];
          }
        ];
        features = {
        };
        resolvedDefaultFeatures = [ "default" ];
      };
      "serde_json" = rec {
        crateName = "serde_json";
        version = "1.0.46";
        edition = "2018";
        sha256 = "0lqr4ak2pkkmq87k11d8zzb6zpsrz0fwycm6vh0qlq4809zivc11";
        authors = [
          "Erick Tryzelaar <erick.tryzelaar@gmail.com>"
          "David Tolnay <dtolnay@gmail.com>"
        ];
        dependencies = [
          {
            name = "itoa";
            packageId = "itoa";
            usesDefaultFeatures = false;
          }
          {
            name = "ryu";
            packageId = "ryu";
          }
          {
            name = "serde";
            packageId = "serde";
            usesDefaultFeatures = false;
          }
        ];
        features = {
          "alloc" = [ "serde/alloc" ];
          "default" = [ "std" ];
          "preserve_order" = [ "indexmap" ];
          "std" = [ "serde/std" ];
        };
        resolvedDefaultFeatures = [
          "default"
          "std"
        ];
      };
      "sha-1" = rec {
        crateName = "sha-1";
        version = "0.8.2";
        edition = "2015";
        sha256 = "1pv387q0r7llk2cqzyq0nivzvkgqgzsiygqzlv7b68z9xl5lvngp";
        libName = "sha1";
        authors = [
          "RustCrypto Developers"
        ];
        dependencies = [
          {
            name = "block-buffer";
            packageId = "block-buffer";
          }
          {
            name = "digest";
            packageId = "digest";
          }
          {
            name = "fake-simd";
            packageId = "fake-simd";
          }
          {
            name = "opaque-debug";
            packageId = "opaque-debug";
          }
        ];
        devDependencies = [
          {
            name = "digest";
            packageId = "digest";
            features = [ "dev" ];
          }
        ];
        features = {
          "asm" = [ "sha1-asm" ];
          "asm-aarch64" = [
            "asm"
            "libc"
          ];
          "default" = [ "std" ];
          "std" = [ "digest/std" ];
        };
      };
      "slug" = rec {
        crateName = "slug";
        version = "0.1.4";
        edition = "2015";
        sha256 = "0wrk0w7mcmnvpmc27fw8dxkip6f6xgwpfgp7mp56yv2bd8p7dg5k";
        authors = [
          "Steven Allen <steven@stebalien.com>"
        ];
        dependencies = [
          {
            name = "deunicode";
            packageId = "deunicode";
          }
        ];

      };
      "strsim" = rec {
        crateName = "strsim";
        version = "0.8.0";
        edition = "2015";
        sha256 = "0sjsm7hrvjdifz661pjxq5w4hf190hx53fra8dfvamacvff139cf";
        authors = [
          "Danny Guo <dannyguo91@gmail.com>"
        ];

      };
      "syn" = rec {
        crateName = "syn";
        version = "1.0.14";
        edition = "2018";
        sha256 = "1xf8g9a3yl41027g5napiwfd7r87y734lf2dqdyyzyfzv183avxg";
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
        ];
        dependencies = [
          {
            name = "proc-macro2";
            packageId = "proc-macro2";
            usesDefaultFeatures = false;
          }
          {
            name = "quote";
            packageId = "quote";
            optional = true;
            usesDefaultFeatures = false;
          }
          {
            name = "unicode-xid";
            packageId = "unicode-xid";
          }
        ];
        features = {
          "default" = [
            "derive"
            "parsing"
            "printing"
            "clone-impls"
            "proc-macro"
          ];
          "printing" = [ "quote" ];
          "proc-macro" = [
            "proc-macro2/proc-macro"
            "quote/proc-macro"
          ];
        };
        resolvedDefaultFeatures = [
          "clone-impls"
          "default"
          "derive"
          "parsing"
          "printing"
          "proc-macro"
          "quote"
          "visit"
        ];
      };
      "tempfile" = rec {
        crateName = "tempfile";
        version = "3.1.0";
        edition = "2018";
        sha256 = "1a9cfdqw70n7bcnkx05aih9xdba8lqazmqlkjpkmn2la6gcj8vks";
        authors = [
          "Steven Allen <steven@stebalien.com>"
          "The Rust Project Developers"
          "Ashley Mannix <ashleymannix@live.com.au>"
          "Jason White <jasonaw0@gmail.com>"
        ];
        dependencies = [
          {
            name = "cfg-if";
            packageId = "cfg-if";
          }
          {
            name = "libc";
            packageId = "libc";
            target = { target, features }: (target."unix" or false);
          }
          {
            name = "rand";
            packageId = "rand";
          }
          {
            name = "redox_syscall";
            packageId = "redox_syscall";
            target = { target, features }: (target."os" == "redox");
          }
          {
            name = "remove_dir_all";
            packageId = "remove_dir_all";
          }
          {
            name = "winapi";
            packageId = "winapi";
            target = { target, features }: (target."windows" or false);
            features = [
              "fileapi"
              "handleapi"
              "winbase"
            ];
          }
        ];

      };
      "tera" = rec {
        crateName = "tera";
        version = "1.0.2";
        edition = "2018";
        sha256 = "0sn8jkzkxzp1wxla5s4f1li8j56137cmkhpk5662wb8w9l1sw0c5";
        authors = [
          "Vincent Prouillet <hello@prouilletvincent.com>"
        ];
        dependencies = [
          {
            name = "chrono";
            packageId = "chrono";
            optional = true;
          }
          {
            name = "chrono-tz";
            packageId = "chrono-tz";
            optional = true;
          }
          {
            name = "globwalk";
            packageId = "globwalk";
          }
          {
            name = "humansize";
            packageId = "humansize";
            optional = true;
          }
          {
            name = "lazy_static";
            packageId = "lazy_static";
          }
          {
            name = "percent-encoding";
            packageId = "percent-encoding";
            optional = true;
          }
          {
            name = "pest";
            packageId = "pest";
          }
          {
            name = "pest_derive";
            packageId = "pest_derive";
          }
          {
            name = "rand";
            packageId = "rand";
            optional = true;
          }
          {
            name = "regex";
            packageId = "regex";
          }
          {
            name = "serde";
            packageId = "serde";
          }
          {
            name = "serde_json";
            packageId = "serde_json";
          }
          {
            name = "slug";
            packageId = "slug";
            optional = true;
          }
          {
            name = "unic-segment";
            packageId = "unic-segment";
            optional = true;
          }
        ];
        features = {
          "builtins" = [
            "slug"
            "percent-encoding"
            "humansize"
            "chrono"
            "chrono-tz"
            "unic-segment"
            "rand"
          ];
          "default" = [ "builtins" ];
          "preserve_order" = [ "serde_json/preserve_order" ];
        };
        resolvedDefaultFeatures = [
          "builtins"
          "chrono"
          "chrono-tz"
          "default"
          "humansize"
          "percent-encoding"
          "rand"
          "slug"
          "unic-segment"
        ];
      };
      "term" = rec {
        crateName = "term";
        version = "0.6.1";
        edition = "2018";
        sha256 = "1ddqxq9hrk8zqq1f8pqhz72vrlfc8vh2xcza2gb623z78lrkm1n0";
        authors = [
          "The Rust Project Developers"
          "Steven Allen"
        ];
        dependencies = [
          {
            name = "dirs";
            packageId = "dirs";
          }
          {
            name = "winapi";
            packageId = "winapi";
            target = { target, features }: (target."windows" or false);
            features = [
              "consoleapi"
              "wincon"
              "handleapi"
              "fileapi"
            ];
          }
        ];
        features = {
        };
        resolvedDefaultFeatures = [ "default" ];
      };
      "textwrap" = rec {
        crateName = "textwrap";
        version = "0.11.0";
        edition = "2015";
        sha256 = "0q5hky03ik3y50s9sz25r438bc4nwhqc6dqwynv4wylc807n29nk";
        authors = [
          "Martin Geisler <martin@geisler.net>"
        ];
        dependencies = [
          {
            name = "unicode-width";
            packageId = "unicode-width";
          }
        ];

      };
      "thread_local" = rec {
        crateName = "thread_local";
        version = "1.0.1";
        edition = "2015";
        sha256 = "054vlrr1vsdy1h4b7n99mr24pnj8928ig9qwzg36wnkld4dns36l";
        authors = [
          "Amanieu d'Antras <amanieu@gmail.com>"
        ];
        dependencies = [
          {
            name = "lazy_static";
            packageId = "lazy_static";
          }
        ];

      };
      "time" = rec {
        crateName = "time";
        version = "0.1.42";
        edition = "2015";
        sha256 = "0vsbvsz0ryxb35dy9j4anxvy8zlaplmjmi0a4z4l64bc135cz3fv";
        authors = [
          "The Rust Project Developers"
        ];
        dependencies = [
          {
            name = "libc";
            packageId = "libc";
          }
          {
            name = "redox_syscall";
            packageId = "redox_syscall";
            target = { target, features }: (target."os" == "redox");
          }
          {
            name = "winapi";
            packageId = "winapi";
            target = { target, features }: (target."windows" or false);
            features = [
              "std"
              "minwinbase"
              "minwindef"
              "ntdef"
              "profileapi"
              "sysinfoapi"
              "timezoneapi"
            ];
          }
        ];
        devDependencies = [
          {
            name = "winapi";
            packageId = "winapi";
            features = [
              "std"
              "processthreadsapi"
              "winbase"
            ];
          }
        ];

      };
      "toml" = rec {
        crateName = "toml";
        version = "0.5.6";
        edition = "2018";
        sha256 = "06n7j8z63hj6g0kj2x6sqwxnm4q3s0q5d873bdk41vqy1cb2vjgz";
        authors = [
          "Alex Crichton <alex@alexcrichton.com>"
        ];
        dependencies = [
          {
            name = "serde";
            packageId = "serde";
          }
        ];
        features = {
          "preserve_order" = [ "indexmap" ];
        };
        resolvedDefaultFeatures = [ "default" ];
      };
      "typenum" = rec {
        crateName = "typenum";
        version = "1.11.2";
        edition = "2015";
        sha256 = "1ybmfpp7j37zmaw50w35wiwx66lbpr0yp1312c0i333b5pz869vd";
        build = "build/main.rs";
        authors = [
          "Paho Lurie-Gregg <paho@paholg.com>"
          "Andre Bogus <bogusandre@gmail.com>"
        ];
        features = {
        };
      };
      "ucd-trie" = rec {
        crateName = "ucd-trie";
        version = "0.1.2";
        edition = "2015";
        sha256 = "1hh6kyzh5xygwy96wfmsf8v8czlzhps2lgbcyhj1xzy1w1xys04g";
        authors = [
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        features = {
          "default" = [ "std" ];
        };
        resolvedDefaultFeatures = [
          "default"
          "std"
        ];
      };
      "unic-char-property" = rec {
        crateName = "unic-char-property";
        version = "0.9.0";
        edition = "2018";
        sha256 = "08g21dn3wwix3ycfl0vrbahn0835nv2q3swm8wms0vwvgm07mid8";
        authors = [
          "The UNIC Project Developers"
        ];
        dependencies = [
          {
            name = "unic-char-range";
            packageId = "unic-char-range";
          }
        ];

      };
      "unic-char-range" = rec {
        crateName = "unic-char-range";
        version = "0.9.0";
        edition = "2018";
        sha256 = "1g0z7iwvjhqspi6194zsff8vy6i3921hpqcrp3v1813hbwnh5603";
        authors = [
          "The UNIC Project Developers"
        ];
        features = {
          "unstable" = [
            "exact-size-is-empty"
            "fused"
            "trusted-len"
          ];
        };
        resolvedDefaultFeatures = [ "default" ];
      };
      "unic-common" = rec {
        crateName = "unic-common";
        version = "0.9.0";
        edition = "2018";
        sha256 = "1g1mm954m0zr497dl4kx3vr09yaly290zs33bbl4wrbaba1gzmw0";
        authors = [
          "The UNIC Project Developers"
        ];
        features = {
        };
        resolvedDefaultFeatures = [ "default" ];
      };
      "unic-segment" = rec {
        crateName = "unic-segment";
        version = "0.9.0";
        edition = "2018";
        sha256 = "08wgz2q6vrdvmbd23kf9pbg8cyzm5q8hq9spc4blzy2ppqk5vvg4";
        authors = [
          "The UNIC Project Developers"
        ];
        dependencies = [
          {
            name = "unic-ucd-segment";
            packageId = "unic-ucd-segment";
          }
        ];

      };
      "unic-ucd-segment" = rec {
        crateName = "unic-ucd-segment";
        version = "0.9.0";
        edition = "2018";
        sha256 = "0027lczcg0r401g6fnzm2bq9fxhgxvri1nlryhhv8192lqic2y90";
        authors = [
          "The UNIC Project Developers"
        ];
        dependencies = [
          {
            name = "unic-char-property";
            packageId = "unic-char-property";
          }
          {
            name = "unic-char-range";
            packageId = "unic-char-range";
          }
          {
            name = "unic-ucd-version";
            packageId = "unic-ucd-version";
          }
        ];

      };
      "unic-ucd-version" = rec {
        crateName = "unic-ucd-version";
        version = "0.9.0";
        edition = "2018";
        sha256 = "1i5hnzpfnxkp4ijfk8kvhpvj84bij575ybqx1b6hyigy6wi2zgcn";
        authors = [
          "The UNIC Project Developers"
        ];
        dependencies = [
          {
            name = "unic-common";
            packageId = "unic-common";
          }
        ];

      };
      "unicode-width" = rec {
        crateName = "unicode-width";
        version = "0.1.7";
        edition = "2015";
        sha256 = "0yflmxkxmm89ckrb3sz58whn491aycrj8cxra0hzzlb72x9rvana";
        authors = [
          "kwantam <kwantam@gmail.com>"
          "Manish Goregaokar <manishsmail@gmail.com>"
        ];
        features = {
          "rustc-dep-of-std" = [
            "std"
            "core"
            "compiler_builtins"
          ];
        };
        resolvedDefaultFeatures = [ "default" ];
      };
      "unicode-xid" = rec {
        crateName = "unicode-xid";
        version = "0.2.0";
        edition = "2015";
        sha256 = "0z09fn515xm7zyr0mmdyxa9mx2f7azcpv74pqmg611iralwpcvl2";
        authors = [
          "erick.tryzelaar <erick.tryzelaar@gmail.com>"
          "kwantam <kwantam@gmail.com>"
        ];
        features = {
        };
        resolvedDefaultFeatures = [ "default" ];
      };
      "vec_map" = rec {
        crateName = "vec_map";
        version = "0.8.1";
        edition = "2015";
        sha256 = "06n8hw4hlbcz328a3gbpvmy0ma46vg1lc0r5wf55900szf3qdiq5";
        authors = [
          "Alex Crichton <alex@alexcrichton.com>"
          "Jorge Aparicio <japaricious@gmail.com>"
          "Alexis Beingessner <a.beingessner@gmail.com>"
          "Brian Anderson <>"
          "tbu- <>"
          "Manish Goregaokar <>"
          "Aaron Turon <aturon@mozilla.com>"
          "Adolfo Ochagavía <>"
          "Niko Matsakis <>"
          "Steven Fackler <>"
          "Chase Southwood <csouth3@illinois.edu>"
          "Eduard Burtescu <>"
          "Florian Wilkens <>"
          "Félix Raimundo <>"
          "Tibor Benke <>"
          "Markus Siemens <markus@m-siemens.de>"
          "Josh Branchaud <jbranchaud@gmail.com>"
          "Huon Wilson <dbau.pp@gmail.com>"
          "Corey Farwell <coref@rwell.org>"
          "Aaron Liblong <>"
          "Nick Cameron <nrc@ncameron.org>"
          "Patrick Walton <pcwalton@mimiga.net>"
          "Felix S Klock II <>"
          "Andrew Paseltiner <apaseltiner@gmail.com>"
          "Sean McArthur <sean.monstar@gmail.com>"
          "Vadim Petrochenkov <>"
        ];
        features = {
          "eders" = [ "serde" ];
        };
      };
      "walkdir" = rec {
        crateName = "walkdir";
        version = "2.3.1";
        edition = "2018";
        sha256 = "0z9g39f49cycdm9vzjf8hnfh3f1csxgd65kmlphj8r2vffy84wbp";
        authors = [
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        dependencies = [
          {
            name = "same-file";
            packageId = "same-file";
          }
          {
            name = "winapi";
            packageId = "winapi";
            target = { target, features }: (target."windows" or false);
            features = [
              "std"
              "winnt"
            ];
          }
          {
            name = "winapi-util";
            packageId = "winapi-util";
            target = { target, features }: (target."windows" or false);
          }
        ];

      };
      "wasi" = rec {
        crateName = "wasi";
        version = "0.9.0+wasi-snapshot-preview1";
        edition = "2018";
        sha256 = "06g5v3vrdapfzvfq662cij7v8a1flwr2my45nnncdv2galrdzkfc";
        authors = [
          "The Cranelift Project Developers"
        ];
        features = {
          "default" = [ "std" ];
          "rustc-dep-of-std" = [
            "compiler_builtins"
            "core"
            "rustc-std-workspace-alloc"
          ];
        };
        resolvedDefaultFeatures = [
          "default"
          "std"
        ];
      };
      "winapi" = rec {
        crateName = "winapi";
        version = "0.3.8";
        edition = "2015";
        sha256 = "1ii9j9lzrhwri0902652awifzx9fpayimbp6hfhhc296xcg0k4w0";
        authors = [
          "Peter Atashian <retep998@gmail.com>"
        ];
        dependencies = [
          {
            name = "winapi-i686-pc-windows-gnu";
            packageId = "winapi-i686-pc-windows-gnu";
            target = { target, features }: (stdenv.hostPlatform.config == "i686-pc-windows-gnu");
          }
          {
            name = "winapi-x86_64-pc-windows-gnu";
            packageId = "winapi-x86_64-pc-windows-gnu";
            target = { target, features }: (stdenv.hostPlatform.config == "x86_64-pc-windows-gnu");
          }
        ];
        features = {
          "debug" = [ "impl-debug" ];
        };
        resolvedDefaultFeatures = [
          "consoleapi"
          "errhandlingapi"
          "fileapi"
          "handleapi"
          "knownfolders"
          "minwinbase"
          "minwindef"
          "ntdef"
          "objbase"
          "processenv"
          "profileapi"
          "shlobj"
          "std"
          "sysinfoapi"
          "timezoneapi"
          "winbase"
          "wincon"
          "winerror"
          "winnt"
        ];
      };
      "winapi-i686-pc-windows-gnu" = rec {
        crateName = "winapi-i686-pc-windows-gnu";
        version = "0.4.0";
        edition = "2015";
        sha256 = "1dmpa6mvcvzz16zg6d5vrfy4bxgg541wxrcip7cnshi06v38ffxc";
        authors = [
          "Peter Atashian <retep998@gmail.com>"
        ];

      };
      "winapi-util" = rec {
        crateName = "winapi-util";
        version = "0.1.3";
        edition = "2018";
        sha256 = "105dq898nah3dwrzr96vvb5srp6g2v5dl5vmzf211lba9iavzksc";
        authors = [
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        dependencies = [
          {
            name = "winapi";
            packageId = "winapi";
            target = { target, features }: (target."windows" or false);
            features = [
              "std"
              "consoleapi"
              "errhandlingapi"
              "fileapi"
              "minwindef"
              "processenv"
              "winbase"
              "wincon"
              "winerror"
              "winnt"
            ];
          }
        ];

      };
      "winapi-x86_64-pc-windows-gnu" = rec {
        crateName = "winapi-x86_64-pc-windows-gnu";
        version = "0.4.0";
        edition = "2015";
        sha256 = "0gqq64czqb64kskjryj8isp62m2sgvx25yyj3kpc2myh85w24bki";
        authors = [
          "Peter Atashian <retep998@gmail.com>"
        ];

      };
    };

    #
    # crate2nix/default.nix (excerpt start)
    #

    /*
      Target (platform) data for conditional dependencies.
      This corresponds roughly to what buildRustCrate is setting.
    */
    defaultTarget = {
      unix = true;
      windows = false;
      fuchsia = true;
      test = false;

      # This doesn't appear to be officially documented anywhere yet.
      # See https://github.com/rust-lang-nursery/rust-forge/issues/101.
      os = if stdenv.hostPlatform.isDarwin then "macos" else stdenv.hostPlatform.parsed.kernel.name;
      arch = stdenv.hostPlatform.parsed.cpu.name;
      family = "unix";
      env = "gnu";
      endian =
        if stdenv.hostPlatform.parsed.cpu.significantByte.name == "littleEndian" then "little" else "big";
      pointer_width = toString stdenv.hostPlatform.parsed.cpu.bits;
      vendor = stdenv.hostPlatform.parsed.vendor.name;
      debug_assertions = false;
    };

    # Filters common temp files and build files.
    # TODO(pkolloch): Substitute with gitignore filter
    sourceFilter =
      name: type:
      let
        baseName = builtins.baseNameOf (builtins.toString name);
      in
      !(
        # Filter out git
        baseName == ".gitignore"
        || (type == "directory" && baseName == ".git")

        # Filter out build results
        || (
          type == "directory"
          && (
            baseName == "target"
            || baseName == "_site"
            || baseName == ".sass-cache"
            || baseName == ".jekyll-metadata"
            || baseName == "build-artifacts"
          )
        )

        # Filter out nix-build result symlinks
        || (type == "symlink" && lib.hasPrefix "result" baseName)

        # Filter out IDE config
        || (type == "directory" && (baseName == ".idea" || baseName == ".vscode"))
        || lib.hasSuffix ".iml" baseName

        # Filter out nix build files
        || baseName == "Cargo.nix"

        # Filter out editor backup / swap files.
        || lib.hasSuffix "~" baseName
        || builtins.match "^\\.sw[a-z]$$" baseName != null
        || builtins.match "^\\..*\\.sw[a-z]$$" baseName != null
        || lib.hasSuffix ".tmp" baseName
        || lib.hasSuffix ".bak" baseName
        || baseName == "tests.nix"
      );

    /*
      Returns a crate which depends on successful test execution
      of crate given as the second argument.

      testCrateFlags: list of flags to pass to the test exectuable
      testInputs: list of packages that should be available during test execution
    */
    crateWithTest =
      {
        crate,
        testCrate,
        testCrateFlags,
        testInputs,
      }:
      assert builtins.typeOf testCrateFlags == "list";
      assert builtins.typeOf testInputs == "list";
      let
        # override the `crate` so that it will build and execute tests instead of
        # building the actual lib and bin targets We just have to pass `--test`
        # to rustc and it will do the right thing.  We execute the tests and copy
        # their log and the test executables to $out for later inspection.
        test =
          let
            drv = testCrate.override (_: {
              buildTests = true;
            });
          in
          pkgs.runCommand "run-tests-${testCrate.name}"
            {
              inherit testCrateFlags;
              buildInputs = testInputs;
            }
            ''
              set -ex

              export RUST_BACKTRACE=1

              # recreate a file hierarchy as when running tests with cargo

              # the source for test data
              ${pkgs.xorg.lndir}/bin/lndir ${crate.src}

              # build outputs
              testRoot=target/debug
              mkdir -p $testRoot

              # executables of the crate
              # we copy to prevent std::env::current_exe() to resolve to a store location
              for i in ${crate}/bin/*; do
                cp "$i" "$testRoot"
              done
              chmod +w -R .

              # test harness executables are suffixed with a hash, like cargo does
              # this allows to prevent name collision with the main
              # executables of the crate
              hash=$(basename $out)
              for file in ${drv}/tests/*; do
                f=$testRoot/$(basename $file)-$hash
                cp $file $f
                $f $testCrateFlags 2>&1 | tee -a $out
              done
            '';
      in
      pkgs.runCommand "${crate.name}-linked"
        {
          inherit (crate) outputs crateName;
          passthru = (crate.passthru or { }) // {
            inherit test;
          };
        }
        ''
          echo tested by ${test}
          ${lib.concatMapStringsSep "\n" (output: "ln -s ${crate.${output}} ${"$"}${output}") crate.outputs}
        '';

    # A restricted overridable version of builtRustCratesWithFeatures.
    buildRustCrateWithFeatures =
      {
        packageId,
        features ? rootFeatures,
        crateOverrides ? defaultCrateOverrides,
        buildRustCrateForPkgsFunc ? null,
        runTests ? false,
        testCrateFlags ? [ ],
        testInputs ? [ ],
      }:
      lib.makeOverridable
        (
          {
            features,
            crateOverrides,
            runTests,
            testCrateFlags,
            testInputs,
          }:
          let
            buildRustCrateForPkgsFuncOverriden =
              if buildRustCrateForPkgsFunc != null then
                buildRustCrateForPkgsFunc
              else
                (
                  if crateOverrides == pkgs.defaultCrateOverrides then
                    buildRustCrateForPkgs
                  else
                    pkgs:
                    (buildRustCrateForPkgs pkgs).override {
                      defaultCrateOverrides = crateOverrides;
                    }
                );
            builtRustCrates = builtRustCratesWithFeatures {
              inherit packageId features;
              buildRustCrateForPkgsFunc = buildRustCrateForPkgsFuncOverriden;
              runTests = false;
            };
            builtTestRustCrates = builtRustCratesWithFeatures {
              inherit packageId features;
              buildRustCrateForPkgsFunc = buildRustCrateForPkgsFuncOverriden;
              runTests = true;
            };
            drv = builtRustCrates.crates.${packageId};
            testDrv = builtTestRustCrates.crates.${packageId};
            derivation =
              if runTests then
                crateWithTest {
                  crate = drv;
                  testCrate = testDrv;
                  inherit testCrateFlags testInputs;
                }
              else
                drv;
          in
          derivation
        )
        {
          inherit
            features
            crateOverrides
            runTests
            testCrateFlags
            testInputs
            ;
        };

    /*
      Returns an attr set with packageId mapped to the result of buildRustCrateForPkgsFunc
      for the corresponding crate.
    */
    builtRustCratesWithFeatures =
      {
        packageId,
        features,
        crateConfigs ? crates,
        buildRustCrateForPkgsFunc,
        runTests,
        target ? defaultTarget,
      }@args:
      assert (builtins.isAttrs crateConfigs);
      assert (builtins.isString packageId);
      assert (builtins.isList features);
      assert (builtins.isAttrs target);
      assert (builtins.isBool runTests);
      let
        rootPackageId = packageId;
        mergedFeatures = mergePackageFeatures (
          args
          // {
            inherit rootPackageId;
            target = target // {
              test = runTests;
            };
          }
        );
        # Memoize built packages so that reappearing packages are only built once.
        builtByPackageIdByPkgs = mkBuiltByPackageIdByPkgs pkgs;
        mkBuiltByPackageIdByPkgs =
          pkgs:
          let
            self = {
              crates = lib.mapAttrs (
                packageId: value: buildByPackageIdForPkgsImpl self pkgs packageId
              ) crateConfigs;
              build = mkBuiltByPackageIdByPkgs pkgs.buildPackages;
            };
          in
          self;
        buildByPackageIdForPkgsImpl =
          self: pkgs: packageId:
          let
            features = mergedFeatures."${packageId}" or [ ];
            crateConfig' = crateConfigs."${packageId}";
            crateConfig = builtins.removeAttrs crateConfig' [
              "resolvedDefaultFeatures"
              "devDependencies"
            ];
            devDependencies = lib.optionals (runTests && packageId == rootPackageId) (
              crateConfig'.devDependencies or [ ]
            );
            dependencies = dependencyDerivations {
              inherit features target;
              buildByPackageId =
                depPackageId:
                # proc_macro crates must be compiled for the build architecture
                if crateConfigs.${depPackageId}.procMacro or false then
                  self.build.crates.${depPackageId}
                else
                  self.crates.${depPackageId};
              dependencies = (crateConfig.dependencies or [ ]) ++ devDependencies;
            };
            buildDependencies = dependencyDerivations {
              inherit features target;
              buildByPackageId = depPackageId: self.build.crates.${depPackageId};
              dependencies = crateConfig.buildDependencies or [ ];
            };
            filterEnabledDependenciesForThis =
              dependencies:
              filterEnabledDependencies {
                inherit dependencies features target;
              };
            dependenciesWithRenames = lib.filter (d: d ? "rename") (
              filterEnabledDependenciesForThis (
                (crateConfig.buildDependencies or [ ]) ++ (crateConfig.dependencies or [ ]) ++ devDependencies
              )
            );
            # Crate renames have the form:
            #
            # {
            #    crate_name = [
            #       { version = "1.2.3"; rename = "crate_name01"; }
            #    ];
            #    # ...
            # }
            crateRenames =
              let
                grouped = lib.groupBy (dependency: dependency.name) dependenciesWithRenames;
                versionAndRename =
                  dep:
                  let
                    package = crateConfigs."${dep.packageId}";
                  in
                  {
                    inherit (dep) rename;
                    version = package.version;
                  };
              in
              lib.mapAttrs (name: choices: builtins.map versionAndRename choices) grouped;
          in
          buildRustCrateForPkgsFunc pkgs (
            crateConfig
            // {
              src =
                crateConfig.src or (pkgs.fetchurl rec {
                  name = "${crateConfig.crateName}-${crateConfig.version}.tar.gz";
                  # https://www.pietroalbini.org/blog/downloading-crates-io/
                  # Not rate-limited, CDN URL.
                  url = "https://static.crates.io/crates/${crateConfig.crateName}/${crateConfig.crateName}-${crateConfig.version}.crate";
                  sha256 =
                    assert (lib.assertMsg (crateConfig ? sha256) "Missing sha256 for ${name}");
                    crateConfig.sha256;
                });
              extraRustcOpts =
                lib.lists.optional (targetFeatures != [ ])
                  "-C target-feature=${lib.concatMapStringsSep "," (x: "+${x}") targetFeatures}";
              inherit
                features
                dependencies
                buildDependencies
                crateRenames
                release
                ;
            }
          );
      in
      builtByPackageIdByPkgs;

    # Returns the actual derivations for the given dependencies.
    dependencyDerivations =
      {
        buildByPackageId,
        features,
        dependencies,
        target,
      }:
      assert (builtins.isList features);
      assert (builtins.isList dependencies);
      assert (builtins.isAttrs target);
      let
        enabledDependencies = filterEnabledDependencies {
          inherit dependencies features target;
        };
        depDerivation = dependency: buildByPackageId dependency.packageId;
      in
      map depDerivation enabledDependencies;

    /*
      Returns a sanitized version of val with all values substituted that cannot
      be serialized as JSON.
    */
    sanitizeForJson =
      val:
      if builtins.isAttrs val then
        lib.mapAttrs (n: v: sanitizeForJson v) val
      else if builtins.isList val then
        builtins.map sanitizeForJson val
      else if builtins.isFunction val then
        "function"
      else
        val;

    # Returns various tools to debug a crate.
    debugCrate =
      {
        packageId,
        target ? defaultTarget,
      }:
      assert (builtins.isString packageId);
      let
        debug = rec {
          # The built tree as passed to buildRustCrate.
          buildTree = buildRustCrateWithFeatures {
            buildRustCrateForPkgsFunc = _: lib.id;
            inherit packageId;
          };
          sanitizedBuildTree = sanitizeForJson buildTree;
          dependencyTree = sanitizeForJson (buildRustCrateWithFeatures {
            buildRustCrateForPkgsFunc = _: crate: {
              "01_crateName" = crate.crateName or false;
              "02_features" = crate.features or [ ];
              "03_dependencies" = crate.dependencies or [ ];
            };
            inherit packageId;
          });
          mergedPackageFeatures = mergePackageFeatures {
            features = rootFeatures;
            inherit packageId target;
          };
          diffedDefaultPackageFeatures = diffDefaultPackageFeatures {
            inherit packageId target;
          };
        };
      in
      {
        internal = debug;
      };

    /*
      Returns differences between cargo default features and crate2nix default
      features.

      This is useful for verifying the feature resolution in crate2nix.
    */
    diffDefaultPackageFeatures =
      {
        crateConfigs ? crates,
        packageId,
        target,
      }:
      assert (builtins.isAttrs crateConfigs);
      let
        prefixValues = prefix: lib.mapAttrs (n: v: { "${prefix}" = v; });
        mergedFeatures = prefixValues "crate2nix" (mergePackageFeatures {
          inherit crateConfigs packageId target;
          features = [ "default" ];
        });
        configs = prefixValues "cargo" crateConfigs;
        combined = lib.foldAttrs (a: b: a // b) { } [
          mergedFeatures
          configs
        ];
        onlyInCargo = builtins.attrNames (
          lib.filterAttrs (n: v: !(v ? "crate2nix") && (v ? "cargo")) combined
        );
        onlyInCrate2Nix = builtins.attrNames (
          lib.filterAttrs (n: v: (v ? "crate2nix") && !(v ? "cargo")) combined
        );
        differentFeatures = lib.filterAttrs (
          n: v:
          (v ? "crate2nix")
          && (v ? "cargo")
          && (v.crate2nix.features or [ ]) != (v."cargo".resolved_default_features or [ ])
        ) combined;
      in
      builtins.toJSON {
        inherit onlyInCargo onlyInCrate2Nix differentFeatures;
      };

    /*
      Returns an attrset mapping packageId to the list of enabled features.

      If multiple paths to a dependency enable different features, the
      corresponding feature sets are merged. Features in rust are additive.
    */
    mergePackageFeatures =
      {
        crateConfigs ? crates,
        packageId,
        rootPackageId ? packageId,
        features ? rootFeatures,
        dependencyPath ? [ crates.${packageId}.crateName ],
        featuresByPackageId ? { },
        target,
        # Adds devDependencies to the crate with rootPackageId.
        runTests ? false,
        ...
      }@args:
      assert (builtins.isAttrs crateConfigs);
      assert (builtins.isString packageId);
      assert (builtins.isString rootPackageId);
      assert (builtins.isList features);
      assert (builtins.isList dependencyPath);
      assert (builtins.isAttrs featuresByPackageId);
      assert (builtins.isAttrs target);
      assert (builtins.isBool runTests);
      let
        crateConfig = crateConfigs."${packageId}" or (builtins.throw "Package not found: ${packageId}");
        expandedFeatures = expandFeatures (crateConfig.features or { }) features;
        depWithResolvedFeatures =
          dependency:
          let
            packageId = dependency.packageId;
            features = dependencyFeatures expandedFeatures dependency;
          in
          {
            inherit packageId features;
          };
        resolveDependencies =
          cache: path: dependencies:
          assert (builtins.isAttrs cache);
          assert (builtins.isList dependencies);
          let
            enabledDependencies = filterEnabledDependencies {
              inherit dependencies target;
              features = expandedFeatures;
            };
            directDependencies = map depWithResolvedFeatures enabledDependencies;
            foldOverCache = op: lib.foldl op cache directDependencies;
          in
          foldOverCache (
            cache:
            { packageId, features }:
            let
              cacheFeatures = cache.${packageId} or [ ];
              combinedFeatures = sortedUnique (cacheFeatures ++ features);
            in
            if cache ? ${packageId} && cache.${packageId} == combinedFeatures then
              cache
            else
              mergePackageFeatures {
                features = combinedFeatures;
                featuresByPackageId = cache;
                inherit
                  crateConfigs
                  packageId
                  target
                  runTests
                  rootPackageId
                  ;
              }
          );
        cacheWithSelf =
          let
            cacheFeatures = featuresByPackageId.${packageId} or [ ];
            combinedFeatures = sortedUnique (cacheFeatures ++ expandedFeatures);
          in
          featuresByPackageId
          // {
            "${packageId}" = combinedFeatures;
          };
        cacheWithDependencies = resolveDependencies cacheWithSelf "dep" (
          crateConfig.dependencies or [ ]
          ++ lib.optionals (runTests && packageId == rootPackageId) (crateConfig.devDependencies or [ ])
        );
        cacheWithAll = resolveDependencies cacheWithDependencies "build" (
          crateConfig.buildDependencies or [ ]
        );
      in
      cacheWithAll;

    # Returns the enabled dependencies given the enabled features.
    filterEnabledDependencies =
      {
        dependencies,
        features,
        target,
      }:
      assert (builtins.isList dependencies);
      assert (builtins.isList features);
      assert (builtins.isAttrs target);

      lib.filter (
        dep:
        let
          targetFunc = dep.target or (features: true);
        in
        targetFunc { inherit features target; }
        && (!(dep.optional or false) || builtins.any (doesFeatureEnableDependency dep) features)
      ) dependencies;

    # Returns whether the given feature should enable the given dependency.
    doesFeatureEnableDependency =
      {
        name,
        rename ? null,
        ...
      }:
      feature:
      let
        prefix = "${name}/";
        len = builtins.stringLength prefix;
        startsWithPrefix = builtins.substring 0 len feature == prefix;
      in
      (rename == null && feature == name) || (rename != null && rename == feature) || startsWithPrefix;

    /*
      Returns the expanded features for the given inputFeatures by applying the
      rules in featureMap.

      featureMap is an attribute set which maps feature names to lists of further
      feature names to enable in case this feature is selected.
    */
    expandFeatures =
      featureMap: inputFeatures:
      assert (builtins.isAttrs featureMap);
      assert (builtins.isList inputFeatures);
      let
        expandFeature =
          feature:
          assert (builtins.isString feature);
          [ feature ] ++ (expandFeatures featureMap (featureMap."${feature}" or [ ]));
        outFeatures = lib.concatMap expandFeature inputFeatures;
      in
      sortedUnique outFeatures;

    /*
       Returns the actual features for the given dependency.

       features: The features of the crate that refers this dependency.
    */
    dependencyFeatures =
      features: dependency:
      assert (builtins.isList features);
      assert (builtins.isAttrs dependency);
      let
        defaultOrNil = if dependency.usesDefaultFeatures or true then [ "default" ] else [ ];
        explicitFeatures = dependency.features or [ ];
        additionalDependencyFeatures =
          let
            dependencyPrefix = (dependency.rename or dependency.name) + "/";
            dependencyFeatures = builtins.filter (f: lib.hasPrefix dependencyPrefix f) features;
          in
          builtins.map (lib.removePrefix dependencyPrefix) dependencyFeatures;
      in
      defaultOrNil ++ explicitFeatures ++ additionalDependencyFeatures;

    # Sorts and removes duplicates from a list of strings.
    sortedUnique =
      features:
      assert (builtins.isList features);
      assert (builtins.all builtins.isString features);
      let
        outFeaturesSet = lib.foldl (set: feature: set // { "${feature}" = 1; }) { } features;
        outFeaturesUnique = builtins.attrNames outFeaturesSet;
      in
      builtins.sort (a: b: a < b) outFeaturesUnique;

    deprecationWarning =
      message: value:
      if strictDeprecation then
        builtins.throw "strictDeprecation enabled, aborting: ${message}"
      else
        builtins.trace message value;

    #
    # crate2nix/default.nix (excerpt end)
    #

  };
}
